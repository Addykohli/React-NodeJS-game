{"ast":null,"code":"var _s = $RefreshSig$();\n// src/components/GameController.js\nimport { useEffect, useContext } from 'react';\nimport { GameContext } from '../context/GameContext';\nimport { tiles } from '../data/tiles';\nconst GameController = () => {\n  _s();\n  const {\n    players,\n    setPlayers,\n    currentPlayerIndex,\n    setCurrentPlayerIndex,\n    originalCount,\n    setOriginalCount,\n    isMoving,\n    setIsMoving,\n    diceRoll,\n    setDiceRoll,\n    pendingPaths,\n    choosePath\n  } = useContext(GameContext);\n  useEffect(() => {\n    if (!isMoving || originalCount <= 0) return;\n    let remaining = originalCount;\n    const initialTotal = originalCount;\n    const updated = [...players];\n    const me = updated[currentPlayerIndex];\n    const step = async () => {\n      while (remaining > 0) {\n        const tile = tiles.find(t => t.id === me.tileId || 1);\n        const candidates = (tile.next || []).filter(n => n.from === me.prevTile);\n\n        // path‐choice logic\n        if (initialTotal === 7 && candidates.length > 1) {\n          // publish choices for UI\n          const choices = candidates.map(c => {\n            const dest = tiles.find(t => t.id === c.to);\n            return {\n              to: c.to,\n              name: dest.name\n            };\n          });\n          // wait for user to pick\n          await new Promise(res => {\n            // store array + callback\n            choosePath(choices);\n            const unwatch = setInterval(() => {\n              if (pendingPaths && pendingPaths.chosen) {\n                me.prevTile = me.tileId;\n                me.tileId = pendingPaths.chosen;\n                clearInterval(unwatch);\n                setPendingPaths(null);\n                res();\n              }\n            }, 100);\n          });\n        } else {\n          let choice;\n          if (initialTotal < 7) {\n            choice = candidates.find(n => n.roll === 'below' || n.roll === 'any');\n          } else if (initialTotal > 7) {\n            choice = candidates.find(n => n.roll === 'above' || n.roll === 'any');\n          } else {\n            // exactly 7 but only one branch\n            choice = candidates[0];\n          }\n          if (!choice) break;\n          me.prevTile = me.tileId;\n          me.tileId = choice.to;\n        }\n        remaining--;\n        setPlayers([...updated]);\n        await new Promise(r => setTimeout(r, 500));\n      }\n\n      // move done!\n      setIsMoving(false);\n      setOriginalCount(0);\n      setDiceRoll(null);\n\n      // → automatically advance turn\n      setCurrentPlayerIndex(idx => (idx + 1) % players.length);\n    };\n    step();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isMoving]);\n  return null;\n};\n_s(GameController, \"LUErk0xUEUvUOXpqbD1JVaIVgcE=\");\n_c = GameController;\nexport default GameController;\nvar _c;\n$RefreshReg$(_c, \"GameController\");","map":{"version":3,"names":["useEffect","useContext","GameContext","tiles","GameController","_s","players","setPlayers","currentPlayerIndex","setCurrentPlayerIndex","originalCount","setOriginalCount","isMoving","setIsMoving","diceRoll","setDiceRoll","pendingPaths","choosePath","remaining","initialTotal","updated","me","step","tile","find","t","id","tileId","candidates","next","filter","n","from","prevTile","length","choices","map","c","dest","to","name","Promise","res","unwatch","setInterval","chosen","clearInterval","setPendingPaths","choice","roll","r","setTimeout","idx","_c","$RefreshReg$"],"sources":["C:/Users/addhy/Desktop/Business_web/client/src/components/GameController.js"],"sourcesContent":["// src/components/GameController.js\r\nimport { useEffect, useContext } from 'react';\r\nimport { GameContext } from '../context/GameContext';\r\nimport { tiles } from '../data/tiles';\r\n\r\nconst GameController = () => {\r\n  const {\r\n    players, setPlayers,\r\n    currentPlayerIndex, setCurrentPlayerIndex,\r\n    originalCount, setOriginalCount,\r\n    isMoving, setIsMoving,\r\n    diceRoll, setDiceRoll,\r\n    pendingPaths, choosePath\r\n  } = useContext(GameContext);\r\n\r\n  useEffect(() => {\r\n    if (!isMoving || originalCount <= 0) return;\r\n\r\n    let remaining = originalCount;\r\n    const initialTotal = originalCount;\r\n    const updated = [...players];\r\n    const me = updated[currentPlayerIndex];\r\n\r\n    const step = async () => {\r\n      while (remaining > 0) {\r\n        const tile = tiles.find(t => t.id === me.tileId || 1);\r\n        const candidates = (tile.next || [])\r\n          .filter(n => n.from === me.prevTile);\r\n\r\n        // path‐choice logic\r\n        if (initialTotal === 7 && candidates.length > 1) {\r\n          // publish choices for UI\r\n          const choices = candidates.map(c => {\r\n            const dest = tiles.find(t => t.id === c.to);\r\n            return { to: c.to, name: dest.name };\r\n          });\r\n          // wait for user to pick\r\n          await new Promise(res => {\r\n            // store array + callback\r\n            choosePath(choices);\r\n            const unwatch = setInterval(() => {\r\n              if (pendingPaths && pendingPaths.chosen) {\r\n                me.prevTile = me.tileId;\r\n                me.tileId = pendingPaths.chosen;\r\n                clearInterval(unwatch);\r\n                setPendingPaths(null);\r\n                res();\r\n              }\r\n            }, 100);\r\n          });\r\n        } else {\r\n          let choice;\r\n          if (initialTotal < 7) {\r\n            choice = candidates.find(n => n.roll === 'below' || n.roll === 'any');\r\n          } else if (initialTotal > 7) {\r\n            choice = candidates.find(n => n.roll === 'above' || n.roll === 'any');\r\n          } else {\r\n            // exactly 7 but only one branch\r\n            choice = candidates[0];\r\n          }\r\n          if (!choice) break;\r\n          me.prevTile = me.tileId;\r\n          me.tileId = choice.to;\r\n        }\r\n\r\n        remaining--;\r\n        setPlayers([...updated]);\r\n        await new Promise(r => setTimeout(r, 500));\r\n      }\r\n\r\n      // move done!\r\n      setIsMoving(false);\r\n      setOriginalCount(0);\r\n      setDiceRoll(null);\r\n\r\n      // → automatically advance turn\r\n      setCurrentPlayerIndex((idx) => (idx + 1) % players.length);\r\n    };\r\n\r\n    step();\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isMoving]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default GameController;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}