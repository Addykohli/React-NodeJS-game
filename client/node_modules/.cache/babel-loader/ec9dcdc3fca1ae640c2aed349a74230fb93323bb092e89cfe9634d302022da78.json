{"ast":null,"code":"var _s = $RefreshSig$();\n// src/components/GameController.js\nimport { useContext, useEffect } from 'react';\nimport { GameContext } from '../context/GameContext';\nimport { tiles } from '../data/tiles';\nconst GameController = () => {\n  _s();\n  const {\n    players,\n    setPlayers,\n    currentPlayerIndex,\n    diceRoll,\n    setDiceRoll,\n    isMoving,\n    setIsMoving\n  } = useContext(GameContext);\n  useEffect(() => {\n    const movePlayer = async () => {\n      // Kick off only once per roll\n      if (!diceRoll || isMoving) return;\n      setIsMoving(true);\n      let steps = diceRoll;\n      const updatedPlayers = [...players];\n      const player = updatedPlayers[currentPlayerIndex];\n      while (steps > 0) {\n        const currentTile = tiles.find(t => t.id === (player.tileId || 1));\n        const prev = player.prevTile;\n        // Determine rollType: on 7 allow both paths, else above/below\n        const rollType = diceRoll === 7 ? 'any' : diceRoll < 7 ? 'below' : 'above';\n\n        // Gather valid next options\n        const candidates = (currentTile.next || []).filter(n => (n.from === prev || n.from == null) && (rollType === 'any' || n.roll === rollType || n.roll === 'any'));\n        let nextId;\n        if (diceRoll === 7 && candidates.length > 1) {\n          // Prompt with actual tile names\n          const names = candidates.map(c => {\n            const t = tiles.find(x => x.id === c.to);\n            return t ? t.name : `${c.to}`;\n          });\n          const choice = window.confirm(`Choose path:\\nOK → ${names[0]}\\nCancel → ${names[1]}`);\n          nextId = choice ? candidates[0].to : candidates[1].to;\n        } else {\n          var _candidates$;\n          nextId = (_candidates$ = candidates[0]) === null || _candidates$ === void 0 ? void 0 : _candidates$.to;\n        }\n        if (!nextId) break;\n        player.prevTile = player.tileId;\n        player.tileId = nextId;\n        setPlayers([...updatedPlayers]);\n        steps -= 1;\n        // Pause to visualize the move\n        // eslint-disable-next-line no-await-in-loop\n        await new Promise(res => setTimeout(res, 500));\n      }\n      setIsMoving(false);\n      // Clear the dice roll so the next player can roll\n      setDiceRoll(null);\n    };\n    movePlayer();\n  }, [diceRoll, isMoving, players, currentPlayerIndex, setPlayers, setIsMoving, setDiceRoll]);\n  return null;\n};\n_s(GameController, \"gMOWMuz5W43BZR5Z+o1pk6vjczk=\");\n_c = GameController;\nexport default GameController;\nvar _c;\n$RefreshReg$(_c, \"GameController\");","map":{"version":3,"names":["useContext","useEffect","GameContext","tiles","GameController","_s","players","setPlayers","currentPlayerIndex","diceRoll","setDiceRoll","isMoving","setIsMoving","movePlayer","steps","updatedPlayers","player","currentTile","find","t","id","tileId","prev","prevTile","rollType","candidates","next","filter","n","from","roll","nextId","length","names","map","c","x","to","name","choice","window","confirm","_candidates$","Promise","res","setTimeout","_c","$RefreshReg$"],"sources":["C:/Users/addhy/Desktop/Business_web/client/src/components/GameController.js"],"sourcesContent":["// src/components/GameController.js\r\nimport { useContext, useEffect } from 'react';\r\nimport { GameContext } from '../context/GameContext';\r\nimport { tiles } from '../data/tiles';\r\n\r\nconst GameController = () => {\r\n  const {\r\n    players,\r\n    setPlayers,\r\n    currentPlayerIndex,\r\n    diceRoll,\r\n    setDiceRoll,\r\n    isMoving,\r\n    setIsMoving\r\n  } = useContext(GameContext);\r\n\r\n  useEffect(() => {\r\n    const movePlayer = async () => {\r\n      // Kick off only once per roll\r\n      if (!diceRoll || isMoving) return;\r\n      setIsMoving(true);\r\n\r\n      let steps = diceRoll;\r\n      const updatedPlayers = [...players];\r\n      const player = updatedPlayers[currentPlayerIndex];\r\n\r\n      while (steps > 0) {\r\n        const currentTile = tiles.find(t => t.id === (player.tileId || 1));\r\n        const prev = player.prevTile;\r\n        // Determine rollType: on 7 allow both paths, else above/below\r\n        const rollType = diceRoll === 7 ? 'any' : diceRoll < 7 ? 'below' : 'above';\r\n\r\n        // Gather valid next options\r\n        const candidates = (currentTile.next || []).filter(n =>\r\n          (n.from === prev || n.from == null) &&\r\n          (rollType === 'any' || n.roll === rollType || n.roll === 'any')\r\n        );\r\n\r\n        let nextId;\r\n        if (diceRoll === 7 && candidates.length > 1) {\r\n          // Prompt with actual tile names\r\n          const names = candidates.map(c => {\r\n            const t = tiles.find(x => x.id === c.to);\r\n            return t ? t.name : `${c.to}`;\r\n          });\r\n          const choice = window.confirm(\r\n            `Choose path:\\nOK → ${names[0]}\\nCancel → ${names[1]}`\r\n          );\r\n          nextId = choice ? candidates[0].to : candidates[1].to;\r\n        } else {\r\n          nextId = candidates[0]?.to;\r\n        }\r\n\r\n        if (!nextId) break;\r\n        player.prevTile = player.tileId;\r\n        player.tileId = nextId;\r\n        setPlayers([...updatedPlayers]);\r\n\r\n        steps -= 1;\r\n        // Pause to visualize the move\r\n        // eslint-disable-next-line no-await-in-loop\r\n        await new Promise(res => setTimeout(res, 500));\r\n      }\r\n\r\n      setIsMoving(false);\r\n      // Clear the dice roll so the next player can roll\r\n      setDiceRoll(null);\r\n    };\r\n\r\n    movePlayer();\r\n  }, [\r\n    diceRoll,\r\n    isMoving,\r\n    players,\r\n    currentPlayerIndex,\r\n    setPlayers,\r\n    setIsMoving,\r\n    setDiceRoll\r\n  ]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default GameController;\r\n"],"mappings":";AAAA;AACA,SAASA,UAAU,EAAEC,SAAS,QAAQ,OAAO;AAC7C,SAASC,WAAW,QAAQ,wBAAwB;AACpD,SAASC,KAAK,QAAQ,eAAe;AAErC,MAAMC,cAAc,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC3B,MAAM;IACJC,OAAO;IACPC,UAAU;IACVC,kBAAkB;IAClBC,QAAQ;IACRC,WAAW;IACXC,QAAQ;IACRC;EACF,CAAC,GAAGZ,UAAU,CAACE,WAAW,CAAC;EAE3BD,SAAS,CAAC,MAAM;IACd,MAAMY,UAAU,GAAG,MAAAA,CAAA,KAAY;MAC7B;MACA,IAAI,CAACJ,QAAQ,IAAIE,QAAQ,EAAE;MAC3BC,WAAW,CAAC,IAAI,CAAC;MAEjB,IAAIE,KAAK,GAAGL,QAAQ;MACpB,MAAMM,cAAc,GAAG,CAAC,GAAGT,OAAO,CAAC;MACnC,MAAMU,MAAM,GAAGD,cAAc,CAACP,kBAAkB,CAAC;MAEjD,OAAOM,KAAK,GAAG,CAAC,EAAE;QAChB,MAAMG,WAAW,GAAGd,KAAK,CAACe,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,MAAMJ,MAAM,CAACK,MAAM,IAAI,CAAC,CAAC,CAAC;QAClE,MAAMC,IAAI,GAAGN,MAAM,CAACO,QAAQ;QAC5B;QACA,MAAMC,QAAQ,GAAGf,QAAQ,KAAK,CAAC,GAAG,KAAK,GAAGA,QAAQ,GAAG,CAAC,GAAG,OAAO,GAAG,OAAO;;QAE1E;QACA,MAAMgB,UAAU,GAAG,CAACR,WAAW,CAACS,IAAI,IAAI,EAAE,EAAEC,MAAM,CAACC,CAAC,IAClD,CAACA,CAAC,CAACC,IAAI,KAAKP,IAAI,IAAIM,CAAC,CAACC,IAAI,IAAI,IAAI,MACjCL,QAAQ,KAAK,KAAK,IAAII,CAAC,CAACE,IAAI,KAAKN,QAAQ,IAAII,CAAC,CAACE,IAAI,KAAK,KAAK,CAChE,CAAC;QAED,IAAIC,MAAM;QACV,IAAItB,QAAQ,KAAK,CAAC,IAAIgB,UAAU,CAACO,MAAM,GAAG,CAAC,EAAE;UAC3C;UACA,MAAMC,KAAK,GAAGR,UAAU,CAACS,GAAG,CAACC,CAAC,IAAI;YAChC,MAAMhB,CAAC,GAAGhB,KAAK,CAACe,IAAI,CAACkB,CAAC,IAAIA,CAAC,CAAChB,EAAE,KAAKe,CAAC,CAACE,EAAE,CAAC;YACxC,OAAOlB,CAAC,GAAGA,CAAC,CAACmB,IAAI,GAAG,GAAGH,CAAC,CAACE,EAAE,EAAE;UAC/B,CAAC,CAAC;UACF,MAAME,MAAM,GAAGC,MAAM,CAACC,OAAO,CAC3B,sBAAsBR,KAAK,CAAC,CAAC,CAAC,cAAcA,KAAK,CAAC,CAAC,CAAC,EACtD,CAAC;UACDF,MAAM,GAAGQ,MAAM,GAAGd,UAAU,CAAC,CAAC,CAAC,CAACY,EAAE,GAAGZ,UAAU,CAAC,CAAC,CAAC,CAACY,EAAE;QACvD,CAAC,MAAM;UAAA,IAAAK,YAAA;UACLX,MAAM,IAAAW,YAAA,GAAGjB,UAAU,CAAC,CAAC,CAAC,cAAAiB,YAAA,uBAAbA,YAAA,CAAeL,EAAE;QAC5B;QAEA,IAAI,CAACN,MAAM,EAAE;QACbf,MAAM,CAACO,QAAQ,GAAGP,MAAM,CAACK,MAAM;QAC/BL,MAAM,CAACK,MAAM,GAAGU,MAAM;QACtBxB,UAAU,CAAC,CAAC,GAAGQ,cAAc,CAAC,CAAC;QAE/BD,KAAK,IAAI,CAAC;QACV;QACA;QACA,MAAM,IAAI6B,OAAO,CAACC,GAAG,IAAIC,UAAU,CAACD,GAAG,EAAE,GAAG,CAAC,CAAC;MAChD;MAEAhC,WAAW,CAAC,KAAK,CAAC;MAClB;MACAF,WAAW,CAAC,IAAI,CAAC;IACnB,CAAC;IAEDG,UAAU,CAAC,CAAC;EACd,CAAC,EAAE,CACDJ,QAAQ,EACRE,QAAQ,EACRL,OAAO,EACPE,kBAAkB,EAClBD,UAAU,EACVK,WAAW,EACXF,WAAW,CACZ,CAAC;EAEF,OAAO,IAAI;AACb,CAAC;AAACL,EAAA,CA5EID,cAAc;AAAA0C,EAAA,GAAd1C,cAAc;AA8EpB,eAAeA,cAAc;AAAC,IAAA0C,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}