{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useContext } from 'react';\nimport { GameContext } from '../context/GameContext';\nimport { tiles } from '../data/tiles';\nconst GameController = () => {\n  _s();\n  const {\n    players,\n    setPlayers,\n    currentPlayerIndex,\n    originalCount,\n    setOriginalCount,\n    isMoving,\n    setIsMoving\n  } = useContext(GameContext);\n  useEffect(() => {\n    if (!isMoving || originalCount <= 0) return;\n    const movePlayer = async () => {\n      let count = originalCount;\n      const updatedPlayers = [...players];\n      const player = updatedPlayers[currentPlayerIndex];\n      while (count > 0) {\n        var _player$currentTile, _currentTile$next;\n        await new Promise(res => setTimeout(res, 500));\n        const currentTile = tiles[(_player$currentTile = player.currentTile) !== null && _player$currentTile !== void 0 ? _player$currentTile : 0];\n        const prev = player.prevTile;\n        const rollType = originalCount === 7 ? 'any' : originalCount < 7 ? 'below' : 'above';\n\n        // Find next based on prev tile and roll condition\n        const candidates = ((_currentTile$next = currentTile.next) === null || _currentTile$next === void 0 ? void 0 : _currentTile$next.filter(n => (n.from === prev || n.from === null || typeof prev === 'undefined') && (n.roll === rollType || n.roll === 'any'))) || [];\n        let nextId;\n        if (originalCount === 7 && candidates.length > 1) {\n          const confirmFirst = window.confirm(`Choose path from options:\\n${candidates.map(c => c.to).join(', ')}`);\n          nextId = confirmFirst ? candidates[0].to : candidates[1].to;\n        } else {\n          var _candidates$;\n          nextId = (_candidates$ = candidates[0]) === null || _candidates$ === void 0 ? void 0 : _candidates$.to;\n        }\n        if (nextId == null) {\n          console.warn('No valid path found from tile', currentTile.id, 'with roll', originalCount);\n          break;\n        }\n        player.prevTile = player.currentTile;\n        player.currentTile = nextId;\n        count--;\n        setPlayers([...updatedPlayers]);\n        setOriginalCount(count);\n      }\n      setIsMoving(false);\n    };\n    movePlayer();\n  }, [isMoving, originalCount, players, currentPlayerIndex, setPlayers, setOriginalCount, setIsMoving]);\n  return null;\n};\n_s(GameController, \"ySH3/1NvShPCbwClxkmCJ7PTqx8=\");\n_c = GameController;\nexport default GameController;\nvar _c;\n$RefreshReg$(_c, \"GameController\");","map":{"version":3,"names":["useEffect","useContext","GameContext","tiles","GameController","_s","players","setPlayers","currentPlayerIndex","originalCount","setOriginalCount","isMoving","setIsMoving","movePlayer","count","updatedPlayers","player","_player$currentTile","_currentTile$next","Promise","res","setTimeout","currentTile","prev","prevTile","rollType","candidates","next","filter","n","from","roll","nextId","length","confirmFirst","window","confirm","map","c","to","join","_candidates$","console","warn","id","_c","$RefreshReg$"],"sources":["C:/Users/addhy/Desktop/Business_web/client/src/components/GameController.js"],"sourcesContent":["import { useEffect, useContext } from 'react';\r\nimport { GameContext } from '../context/GameContext';\r\nimport { tiles } from '../data/tiles';\r\n\r\nconst GameController = () => {\r\n  const {\r\n    players, setPlayers,\r\n    currentPlayerIndex,\r\n    originalCount, setOriginalCount,\r\n    isMoving, setIsMoving\r\n  } = useContext(GameContext);\r\n\r\n  useEffect(() => {\r\n    if (!isMoving || originalCount <= 0) return;\r\n\r\n    const movePlayer = async () => {\r\n      let count = originalCount;\r\n      const updatedPlayers = [...players];\r\n      const player = updatedPlayers[currentPlayerIndex];\r\n\r\n      while (count > 0) {\r\n        await new Promise(res => setTimeout(res, 500));\r\n\r\n        const currentTile = tiles[player.currentTile ?? 0];\r\n\r\n        const prev = player.prevTile;\r\n        const rollType = originalCount === 7 ? 'any' : originalCount < 7 ? 'below' : 'above';\r\n\r\n        // Find next based on prev tile and roll condition\r\n        const candidates = currentTile.next?.filter(n =>\r\n          (n.from === prev || n.from === null || typeof prev === 'undefined') &&\r\n          (n.roll === rollType || n.roll === 'any')\r\n        ) || [];\r\n\r\n        let nextId;\r\n\r\n        if (originalCount === 7 && candidates.length > 1) {\r\n          const confirmFirst = window.confirm(`Choose path from options:\\n${candidates.map(c => c.to).join(', ')}`);\r\n          nextId = confirmFirst ? candidates[0].to : candidates[1].to;\r\n        } else {\r\n          nextId = candidates[0]?.to;\r\n        }\r\n\r\n        if (nextId == null) {\r\n          console.warn('No valid path found from tile', currentTile.id, 'with roll', originalCount);\r\n          break;\r\n        }\r\n\r\n        player.prevTile = player.currentTile;\r\n        player.currentTile = nextId;\r\n        count--;\r\n\r\n        setPlayers([...updatedPlayers]);\r\n        setOriginalCount(count);\r\n      }\r\n\r\n      setIsMoving(false);\r\n    };\r\n\r\n    movePlayer();\r\n  }, [\r\n    isMoving,\r\n    originalCount,\r\n    players,\r\n    currentPlayerIndex,\r\n    setPlayers,\r\n    setOriginalCount,\r\n    setIsMoving\r\n  ]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default GameController;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}