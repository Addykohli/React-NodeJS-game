{"ast":null,"code":"var _s = $RefreshSig$();\n// src/components/GameController.js\nimport { useContext, useEffect } from 'react';\nimport { GameContext } from '../context/GameContext';\nimport { tiles } from '../data/tiles';\nconst GameController = () => {\n  _s();\n  const {\n    players,\n    setPlayers,\n    currentPlayerIndex,\n    diceRoll,\n    setIsMoving,\n    isMoving\n  } = useContext(GameContext);\n  useEffect(() => {\n    const movePlayer = async () => {\n      // Only start moving once diceRoll is set and not already moving\n      if (!diceRoll || isMoving) return;\n      setIsMoving(true);\n      let steps = diceRoll;\n      const updatedPlayers = [...players];\n      const player = updatedPlayers[currentPlayerIndex];\n      while (steps > 0) {\n        // Find current tile data (default to tile 1)\n        const currentTile = tiles.find(t => t.id === (player.tileId || 1));\n        const prev = player.prevTile;\n        const rollType = diceRoll === 7 ? 'any' : diceRoll < 7 ? 'below' : 'above';\n\n        // Filter next paths based on previous tile and roll direction\n        const candidates = (currentTile.next || []).filter(n => (n.from === prev || n.from == null) && (rollType === 'any' || n.roll === rollType || n.roll === 'any'));\n        if (diceRoll === 7 && candidates.length > 1) {\n          // Prompt user to choose path by tile name\n          const names = candidates.map(c => {\n            const tile = tiles.find(t => t.id === c.to);\n            return tile ? tile.name : c.to;\n          });\n          const choice = window.confirm(`Choose between: ${names.join(' or ')}` + '\\nOK = ' + names[0] + ', Cancel = ' + names[1]);\n          player.prevTile = player.tileId;\n          player.tileId = choice ? candidates[0].to : candidates[1].to;\n        } else {\n          // Default to first available path\n          if (!candidates[0]) break;\n          player.prevTile = player.tileId;\n          player.tileId = candidates[0].to;\n        }\n        setPlayers([...updatedPlayers]);\n        steps -= 1;\n        // Pause for animation timing\n        // eslint-disable-next-line no-await-in-loop\n        await new Promise(res => setTimeout(res, 500));\n      }\n      setIsMoving(false);\n    };\n    movePlayer();\n  }, [diceRoll, isMoving, players, currentPlayerIndex, setPlayers, setIsMoving]);\n  return null;\n};\n_s(GameController, \"F0WQTOXL1YoSlVTmyhmOb7sj6jU=\");\n_c = GameController;\nexport default GameController;\nvar _c;\n$RefreshReg$(_c, \"GameController\");","map":{"version":3,"names":["useContext","useEffect","GameContext","tiles","GameController","_s","players","setPlayers","currentPlayerIndex","diceRoll","setIsMoving","isMoving","movePlayer","steps","updatedPlayers","player","currentTile","find","t","id","tileId","prev","prevTile","rollType","candidates","next","filter","n","from","roll","length","names","map","c","tile","to","name","choice","window","confirm","join","Promise","res","setTimeout","_c","$RefreshReg$"],"sources":["C:/Users/addhy/Desktop/Business_web/client/src/components/GameController.js"],"sourcesContent":["// src/components/GameController.js\r\nimport { useContext, useEffect } from 'react';\r\nimport { GameContext } from '../context/GameContext';\r\nimport { tiles } from '../data/tiles';\r\n\r\nconst GameController = () => {\r\n  const {\r\n    players,\r\n    setPlayers,\r\n    currentPlayerIndex,\r\n    diceRoll,\r\n    setIsMoving,\r\n    isMoving\r\n  } = useContext(GameContext);\r\n\r\n  useEffect(() => {\r\n    const movePlayer = async () => {\r\n      // Only start moving once diceRoll is set and not already moving\r\n      if (!diceRoll || isMoving) return;\r\n      setIsMoving(true);\r\n\r\n      let steps = diceRoll;\r\n      const updatedPlayers = [...players];\r\n      const player = updatedPlayers[currentPlayerIndex];\r\n\r\n      while (steps > 0) {\r\n        // Find current tile data (default to tile 1)\r\n        const currentTile = tiles.find(t => t.id === (player.tileId || 1));\r\n        const prev = player.prevTile;\r\n        const rollType = diceRoll === 7 ? 'any' : diceRoll < 7 ? 'below' : 'above';\r\n\r\n        // Filter next paths based on previous tile and roll direction\r\n        const candidates = (currentTile.next || []).filter(n =>\r\n          (n.from === prev || n.from == null) &&\r\n          (rollType === 'any' || n.roll === rollType || n.roll === 'any')\r\n        );\r\n\r\n        if (diceRoll === 7 && candidates.length > 1) {\r\n          // Prompt user to choose path by tile name\r\n          const names = candidates.map(c => {\r\n            const tile = tiles.find(t => t.id === c.to);\r\n            return tile ? tile.name : c.to;\r\n          });\r\n          const choice = window.confirm(\r\n            `Choose between: ${names.join(' or ')}` +\r\n            '\\nOK = ' + names[0] + ', Cancel = ' + names[1]\r\n          );\r\n          player.prevTile = player.tileId;\r\n          player.tileId = choice ? candidates[0].to : candidates[1].to;\r\n        } else {\r\n          // Default to first available path\r\n          if (!candidates[0]) break;\r\n          player.prevTile = player.tileId;\r\n          player.tileId = candidates[0].to;\r\n        }\r\n\r\n        setPlayers([...updatedPlayers]);\r\n        steps -= 1;\r\n        // Pause for animation timing\r\n        // eslint-disable-next-line no-await-in-loop\r\n        await new Promise(res => setTimeout(res, 500));\r\n      }\r\n\r\n      setIsMoving(false);\r\n    };\r\n\r\n    movePlayer();\r\n  }, [diceRoll, isMoving, players, currentPlayerIndex, setPlayers, setIsMoving]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default GameController;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}